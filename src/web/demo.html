<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LG전자-연세대 HVAC LLM 1차년도 데모</title>
    <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/variable/pretendardvariable.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>

<body>
    <div class="chat-container">
        <!-- Header section -->
        <div class="header-container">
            LG전자-연세대 HVAC LLM 1차년도 데모
            <div style="margin-left: auto; display: flex; align-items: center;">
                <img src="{{ url_for('static', filename='lg_logo.png') }}" alt="LG Logo">
                <img src="{{ url_for('static', filename='yonsei_logo.png') }}" alt="Yonsei Logo">
            </div>
        </div>

        <!-- Main content - Three column layout -->
        <div class="main-content">
            <div class="left-column">
                <!-- Metadata section -->
                <div class="metadata-column">
                    <div class="metadata-container">
                        <label for="metadataSelect" style="font-size: 14px;">메타데이터 선택:</label>
                        <select id="metadataSelect">
                            <option value="">로딩 중...</option>
                        </select>
                    </div>
                    <div class="description-box" id="metadataDescription">
                        <!-- Add title-body vertical boxes -->
                        <div class="metadata-item">
                            <!-- <div class="metadata-title">제목</div>
                            <div class="metadata-content">
                                정보
                            </div> -->
                        </div>
                    </div>
                </div>

                <!-- Status section (vertically below metadata) -->
                <div class="status-section" id="statusSection">
                    <div class="status-header">
                        <h3>시스템 상태</h3>
                        <button id="statusToggleBtn" class="status-toggle-btn active">상태 추적 끄기</button>
                    </div>
                    <div class="status-content" id="statusContent">
                        <div class="status-item">
                            <span class="status-label">모델 상태:</span>
                            <div class="status-indicators">
                                <div class="status-indicator">
                                    <span>입력처리:</span>
                                    <span id="inputStatus" class="status-badge">확인 중...</span>
                                </div>
                                <div class="status-indicator">
                                    <span>응답생성:</span>
                                    <span id="responseStatus" class="status-badge">확인 중...</span>
                                </div>
                            </div>
                        </div>
                        <div class="status-item">
                            <span class="status-label">GPU 상태:</span>
                            <div id="gpuStatusContainer" class="gpu-status-container">
                                <div class="gpu-status-loading">로딩 중...</div>
                            </div>
                        </div>
                        <div class="status-last-updated" id="statusLastUpdated"></div>
                    </div>
                </div>
            </div>

            <!-- Middle column - Chat -->
            <div class="chat-column">
                <div class="chat-window" id="chatWindow">
                    <!-- Chat messages will appear here -->
                </div>

                <div class="suggestion-container">
                    <!-- Suggested input buttons will be added here -->
                </div>

                <div class="input-container">
                    <input type="text" id="sentenceInput" placeholder="Enter a message...">
                    <button id="sendButton">Send</button>
                    <button class="new-session-button" id="newSessionButton">New Session</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const debugStates = {};
        // DOM Elements
        const sendButton = document.getElementById('sendButton');
        const newSessionButton = document.getElementById('newSessionButton');
        const sentenceInput = document.getElementById('sentenceInput');
        const chatWindow = document.getElementById('chatWindow');
        const metadataSelect = document.getElementById('metadataSelect');
        const metadataDescription = document.getElementById('metadataDescription');
        const statusSection = document.getElementById('statusSection');
        const statusToggleBtn = document.getElementById('statusToggleBtn');
        const statusLastUpdated = document.getElementById('statusLastUpdated');
        let waitingMessageElement = null;
        let availableMetadatas = {};
        let currentResponseId = null;
        let currentBotMessage = null;
        let currentDebugMessages = null;
        let currentFinalResponse = null;
        let currentToggleButton = null;
        let currentDebugContainer = null;
        let hasReceivedAnyMessage = false;
        let hasReceivedFinalResponse = false;
        let statusInterval = null;
        let isStatusTrackingActive = false;
        let lastStatusUpdate = null;
        // Store processing times for each response
        const processingTimes = {};

        // Event Listeners
        sentenceInput.addEventListener('keyup', e => e.key === 'Enter' && sendRequest());
        sendButton.addEventListener('click', sendRequest);
        newSessionButton.addEventListener('click', newSession);
        metadataSelect.addEventListener('change', () => updateMetadataDescription(metadataSelect.value));
        statusToggleBtn.addEventListener('click', toggleStatusTracking);

        // restoreProcessingTimes 함수 아래에 추가 또는 함수 내에 통합
        function restoreDebugStates() {
            const savedStates = localStorage.getItem('debugStates');
            if (savedStates) {
                const states = JSON.parse(savedStates);

                // 모든 메시지 열기/닫기 상태 복원
                document.querySelectorAll('.message-toggle').forEach(button => {
                    const responseId = button.dataset.targetId;
                    if (responseId && responseId in states) {
                        const isShowing = states[responseId]; // true면 표시, false면 숨김
                        const botMessage = button.closest('.bot-message');
                        const debugMessages = botMessage.querySelector('.debug-messages');

                        if (isShowing) {
                            // 디버그 메시지 표시
                            debugMessages.classList.remove('debug-hidden');
                            button.textContent = '디버그 메시지 숨기기';
                        } else {
                            // 디버그 메시지 숨김
                            debugMessages.classList.add('debug-hidden');
                            const time = processingTimes[responseId];
                            updateToggleButtonText(button, time);
                        }
                    }
                });
            }
        }

        // Initialize
        window.onload = () => {
            const chatHistory = localStorage.getItem('chatHistory');
            if (chatHistory) {
                chatWindow.innerHTML = chatHistory;
                reconnectToggleListeners();
                restoreProcessingTimes();
                restoreDebugStates(); // 디버그 상태 복원 추가
                scrollChatWindow();
            }

            // 상태 추적 상태 복원
            const trackingActive = localStorage.getItem('statusTrackingActive');
            if (trackingActive !== null) {
                isStatusTrackingActive = trackingActive === 'true';
                updateStatusTrackingUI();
            }

            loadMetadatas();

            // 상태 추적 시작 여부 결정
            if (isStatusTrackingActive) {
                startStatusTracking();
            } else {
                // 상태 추적이 꺼진 상태라면 한 번만 상태 확인
                checkStatus();
            }
        };

        // 처리 시간 복원 함수
        function restoreProcessingTimes() {
            const savedTimes = localStorage.getItem('processingTimes');
            if (savedTimes) {
                Object.assign(processingTimes, JSON.parse(savedTimes));
            }

            // 모든 토글 버튼에 처리 시간 표시 업데이트
            document.querySelectorAll('.message-toggle').forEach(button => {
                const responseId = button.dataset.targetId;
                if (responseId && processingTimes[responseId]) {
                    updateToggleButtonText(button, processingTimes[responseId]);
                }
            });
        }

        // 토글 버튼 텍스트 업데이트 함수
        function updateToggleButtonText(button, time, isHidden = true) {
            if (isHidden) {
                button.textContent = `디버그 메시지 표시${time ? ` (${time}초)` : ''}`;
            } else {
                button.textContent = '디버그 메시지 숨기기';
            }
        }

        // 상태 추적 토글 함수
        function toggleStatusTracking() {
            isStatusTrackingActive = !isStatusTrackingActive;
            localStorage.setItem('statusTrackingActive', isStatusTrackingActive);

            if (isStatusTrackingActive) {
                startStatusTracking();
            } else {
                stopStatusTracking();
            }

            updateStatusTrackingUI();
        }

        // 상태 추적 UI 업데이트
        function updateStatusTrackingUI() {
            if (isStatusTrackingActive) {
                statusToggleBtn.textContent = '상태 추적 끄기';
                statusToggleBtn.classList.remove('inactive');
                statusToggleBtn.classList.add('active');
            } else {
                statusToggleBtn.textContent = '상태 추적 켜기';
                statusToggleBtn.classList.remove('active');
                statusToggleBtn.classList.add('inactive');
            }
        }

        // 상태 추적 시작
        function startStatusTracking() {
            if (statusInterval) {
                clearInterval(statusInterval);
            }
            statusInterval = setInterval(checkStatus, 1000);
            // 즉시 한 번 체크
            checkStatus();
        }

        // 상태 추적 중지
        function stopStatusTracking() {
            if (statusInterval) {
                clearInterval(statusInterval);
                statusInterval = null;
            }
        }

        // 토글 이벤트 리스너 재연결 (페이지 로드 후)
        function reconnectToggleListeners() {
            document.querySelectorAll('.message-toggle').forEach(button => {
                button.addEventListener('click', toggleDebugMessages);
            });
        }

        // Load metadata from server
        function loadMetadatas() {
            fetch(`http://1.233.219.93:{{ port_number }}/available_metadatas`)
                .then(response => response.json())
                .then(data => {
                    availableMetadatas = data;
                    metadataSelect.innerHTML = '';

                    const metadataNames = Object.keys(availableMetadatas);
                    metadataNames.forEach(name => {
                        const option = document.createElement('option');
                        option.value = name;
                        option.textContent = name;
                        metadataSelect.appendChild(option);
                    });

                    if (metadataNames.length > 0) {
                        metadataSelect.value = metadataNames[0];
                        updateMetadataDescription(metadataNames[0]);
                    }
                })
                .catch(error => {
                    console.error('메타데이터 로드 오류:', error);
                    metadataSelect.innerHTML = '<option value="">메타데이터 로드 실패</option>';
                });
        }

        // Create metadata description recursively
        function createMetadataDescriptionFromList(data, depth = 0) {
            if (depth === 0) metadataDescription.innerHTML = '';

            for (const item of data) {
                if (Array.isArray(item) && item.length === 2) {
                    const [title, content] = item;

                    if (Array.isArray(content)) {
                        // Section header
                        const sectionEl = document.createElement('div');
                        sectionEl.className = 'metadata-section';
                        sectionEl.style.paddingLeft = `${depth * 16}px`;
                        sectionEl.style.marginBottom = '5px';
                        sectionEl.style.fontWeight = 'bold';
                        sectionEl.textContent = title;
                        metadataDescription.appendChild(sectionEl);

                        if (content.every(subItem => Array.isArray(subItem))) {
                            // Process nested arrays
                            createMetadataDescriptionFromList(content, depth + 1);
                        } else {
                            // Simple list items
                            for (const subItem of content) {
                                const itemEl = document.createElement('div');
                                itemEl.className = 'metadata-item';
                                itemEl.style.paddingLeft = `${(depth + 1) * 16}px`;
                                itemEl.style.marginBottom = '4px';
                                itemEl.textContent = `| ${subItem}`;
                                metadataDescription.appendChild(itemEl);
                            }
                        }
                    } else {
                        // Key-value pair
                        const itemEl = document.createElement('div');
                        itemEl.className = 'metadata-item';
                        itemEl.style.paddingLeft = `${depth * 16}px`;
                        itemEl.style.marginBottom = '4px';
                        itemEl.innerHTML = `<span style="font-weight: bold;">${title}:</span> ${content}`;
                        metadataDescription.appendChild(itemEl);
                    }
                } else if (Array.isArray(item) && item.length >= 2 && typeof item[0] === 'string') {
                    // Special case array items
                    const keyEl = document.createElement('div');
                    keyEl.className = 'metadata-item';
                    keyEl.style.paddingLeft = `${(depth + 1) * 16}px`;
                    keyEl.style.marginBottom = '4px';
                    keyEl.textContent = item.join(': ');
                    metadataDescription.appendChild(keyEl);
                } else {
                    // Simple string item
                    const itemEl = document.createElement('div');
                    itemEl.className = 'metadata-item';
                    itemEl.style.paddingLeft = `${(depth + 1) * 16}px`;
                    itemEl.style.marginBottom = '4px';
                    itemEl.textContent = item;
                    metadataDescription.appendChild(itemEl);
                }
            }
        }

        // Update metadata description
        function updateMetadataDescription(metadataName) {
            if (availableMetadatas[metadataName]) {
                let description = availableMetadatas[metadataName]['metadata_repr'];
                let suggestedInputs = availableMetadatas[metadataName]['suggested_inputs'];
                createMetadataDescriptionFromList(description);
                updateSuggestedButtons(suggestedInputs);
            } else {
                metadataDescription.innerHTML = '선택된 메타데이터에 대한 정보가 없습니다.';
            }
        }

        // Helper functions
        const escapeHTML = str => str.replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");

        const formatText = str => {
            const escapedStr = escapeHTML(str);
            return escapedStr
                .replace(/&lt;h1 (.*?)&gt;/g, '<div class="h1">$1</div>')
                .replace(/&lt;h2 (.*?)&gt;/g, '<div class="h2">$1</div>')
                .replace(/&lt;h3 (.*?)&gt;/g, '<div class="h3">$1</div>')
                .replace(/^((?!<div class="h[123]">).+)$/gm, '<div class="normal">$1</div>')
                .replace(/&lt;br&gt;/g, '\n');
        };

        // Send request to server
        function sendRequest() {
            const sentence = sentenceInput.value.trim();
            const selectedMetadata = metadataSelect.value;

            if (!sentence) return;
            if (!selectedMetadata) {
                alert('메타데이터를 선택해주세요.');
                return;
            }

            // 고유 응답 ID 생성
            currentResponseId = 'response-' + Date.now();
            hasReceivedAnyMessage = false;
            hasReceivedFinalResponse = false;

            // Add user message to chat
            appendMessage('user', sentence);
            saveChatHistory();
            sentenceInput.value = '';
            scrollChatWindow();

            // Disable inputs during processing
            [sendButton, newSessionButton, sentenceInput, metadataSelect].forEach(el => el.disabled = true);
            // Also disable suggestion buttons
            document.querySelectorAll('.suggestion-button').forEach(button => button.disabled = true);

            // 대기 메시지 표시
            showWaitingMessage();

            // 봇 메시지 생성 (초기에는 표시하지 않음)
            const botMessage = document.createElement('div');
            botMessage.classList.add('chat-message', 'bot-message');
            botMessage.style.display = 'none'; // 초기에는 숨김
            chatWindow.appendChild(botMessage);

            // 디버그 메시지 영역 생성
            const debugMessagesEl = document.createElement('div');
            debugMessagesEl.classList.add('debug-messages');
            botMessage.appendChild(debugMessagesEl);

            // 최종 응답 영역 생성 (초기에는 빈 상태)
            const finalResponseEl = document.createElement('div');
            finalResponseEl.classList.add('final-response');
            finalResponseEl.style.display = 'none';
            botMessage.appendChild(finalResponseEl);

            // 토글 버튼 생성 (초기에는 숨김)
            const toggleButton = document.createElement('button');
            toggleButton.classList.add('message-toggle');
            toggleButton.textContent = '디버그 메시지 표시';
            toggleButton.style.display = 'none';
            toggleButton.dataset.targetId = currentResponseId;
            toggleButton.addEventListener('click', toggleDebugMessages);
            botMessage.appendChild(toggleButton);

            // 현재 참조 저장
            currentBotMessage = botMessage;
            currentDebugMessages = debugMessagesEl;
            currentFinalResponse = finalResponseEl;
            currentToggleButton = toggleButton;
            currentDebugContainer = debugMessagesEl; // 이전 코드와의 호환성 유지

            // Create EventSource for streaming response
            const eventSource = new EventSource(
                `http://1.233.219.93:{{ port_number }}/process?sentence=${encodeURIComponent(sentence)}&metadata_name=${encodeURIComponent(selectedMetadata)}`
            );

            eventSource.onmessage = function (event) {
                try {
                    const responseData = JSON.parse(event.data);
                    const messageType = responseData.type;
                    const content = responseData.content;

                    // 어떤 메시지든 처음 도착하면 대기 메시지 제거 및 봇 메시지 표시
                    if (!hasReceivedAnyMessage) {
                        hasReceivedAnyMessage = true;
                        removeWaitingMessage();
                        currentBotMessage.style.display = 'block';
                    }

                    if (messageType === "debug") {
                        // 디버그 메시지 추가
                        const debugMessageEl = document.createElement('div');
                        debugMessageEl.classList.add('debug-message');

                        // 이미지 URL이 포함된 경우 (HTML 태그)
                        if (content.includes('<img')) {
                            debugMessageEl.innerHTML = content;
                        } else {
                            // 일반 텍스트인 경우
                            debugMessageEl.innerHTML = formatText(content);
                        }

                        currentDebugMessages.appendChild(debugMessageEl);
                        scrollChatWindow();
                    } else if (messageType === "response") {
                        // 응답 메시지 처리

                        // 응답 내용 설정 (이미 표시되고 있었다면 추가)
                        if (!hasReceivedFinalResponse) {
                            // 처음 응답이 온 경우
                            hasReceivedFinalResponse = true;
                            currentFinalResponse.innerHTML = formatText(content);
                            currentFinalResponse.style.display = 'block';

                            // 디버그 메시지 숨기기
                            currentDebugMessages.classList.add('debug-hidden');

                            // 토글 버튼 표시
                            currentToggleButton.style.display = 'block';
                        } else {
                            // 이미 응답이 있는 경우(그래프 이후에 텍스트 등), 내용 추가
                            currentFinalResponse.innerHTML += '<div class="response-divider"></div>' + formatText(content);
                        }
                    } else if (messageType === "graph") {
                        // 그래프 메시지 처리 - response처럼 처리

                        // 최종 응답 영역에 표시
                        if (!hasReceivedFinalResponse) {
                            // 첫 응답으로 그래프가 온 경우
                            hasReceivedFinalResponse = true;
                            currentFinalResponse.innerHTML = content; // 그래프는 HTML 형태로 전달됨
                            currentFinalResponse.style.display = 'block';

                            // 디버그 메시지 숨기기
                            currentDebugMessages.classList.add('debug-hidden');

                            // 토글 버튼 표시
                            currentToggleButton.style.display = 'block';
                        } else {
                            // 이미 다른 응답이 있는 경우, 구분자와 함께 추가
                            currentFinalResponse.innerHTML += '<div class="response-divider"></div>' + content;
                        }

                        scrollChatWindow();
                    } else if (messageType === "time") {
                        // 처리 시간 저장 (현재 응답 ID로 저장)
                        processingTimes[currentResponseId] = content;

                        // 처리 시간 적용
                        updateToggleButtonText(currentToggleButton, content);

                        // 로컬 스토리지에 처리 시간 저장
                        localStorage.setItem('processingTimes', JSON.stringify(processingTimes));
                    } else if (messageType === "finish") {
                        // 처리 완료
                        eventSource.close();

                        // 최종 응답이 없었다면 디버그 메시지 표시
                        if (!hasReceivedFinalResponse) {
                            currentDebugMessages.classList.remove('debug-hidden');
                            currentToggleButton.style.display = 'none'; // 토글 버튼 필요 없음
                        }

                        // 입력 폼 다시 활성화
                        [sendButton, newSessionButton, sentenceInput, metadataSelect].forEach(el => el.disabled = false);
                        document.querySelectorAll('.suggestion-button').forEach(button => button.disabled = false);

                        saveChatHistory();
                    }
                } catch (error) {
                    console.error('응답 파싱 오류:', error, event.data);
                    if (waitingMessageElement) {
                        removeWaitingMessage();
                    }

                    // 에러 발생 시 이벤트 소스 종료 및 입력 폼 재활성화
                    eventSource.close();
                    [sendButton, newSessionButton, sentenceInput, metadataSelect].forEach(el => el.disabled = false);
                    document.querySelectorAll('.suggestion-button').forEach(button => button.disabled = false);
                }
            };

            eventSource.onerror = function (error) {
                console.error('EventSource 에러:', error);

                // 만약 대기 메시지가 있다면 제거
                if (waitingMessageElement) {
                    removeWaitingMessage();
                }

                // 이미 봇 메시지가 생성되어 있는지 확인
                if (hasReceivedAnyMessage && currentBotMessage) {
                    // 이미 메시지를 받았다면 기존 봇 메시지 내에 에러 메시지 추가
                    const errorMessageEl = document.createElement('div');
                    errorMessageEl.classList.add('error-message');
                    errorMessageEl.style.color = '#c62828';
                    errorMessageEl.style.padding = '10px';
                    errorMessageEl.style.marginTop = '10px';
                    errorMessageEl.style.border = '1px solid #ffcdd2';
                    errorMessageEl.style.borderRadius = '5px';
                    errorMessageEl.style.backgroundColor = '#ffebee';
                    errorMessageEl.innerText = '요청 처리 중 오류가 발생했습니다.';

                    // 최종 응답이 표시되어 있지 않으면 디버그 메시지 영역에 추가
                    if (!hasReceivedFinalResponse) {
                        currentDebugMessages.appendChild(errorMessageEl);
                        currentDebugMessages.classList.remove('debug-hidden');
                        if (currentToggleButton) {
                            currentToggleButton.style.display = 'none'; // 토글 버튼 숨김
                        }
                    } else {
                        // 최종 응답이 이미 표시되어 있으면 그 아래에 추가
                        currentFinalResponse.appendChild(errorMessageEl);
                    }
                } else {
                    // 아직 봇 메시지가 생성되지 않았다면 새로운 봇 메시지 생성
                    const botMessage = document.createElement('div');
                    botMessage.classList.add('chat-message', 'bot-message');

                    const errorContent = document.createElement('div');
                    errorContent.classList.add('final-response');
                    errorContent.style.color = '#c62828';
                    errorContent.innerText = '요청 처리 중 오류가 발생했습니다.';

                    botMessage.appendChild(errorContent);
                    chatWindow.appendChild(botMessage);
                }

                // 이벤트 소스 종료 및 입력 폼 재활성화
                eventSource.close();
                [sendButton, newSessionButton, sentenceInput, metadataSelect].forEach(el => el.disabled = false);
                document.querySelectorAll('.suggestion-button').forEach(button => button.disabled = false);

                saveChatHistory();
            };
        }

        // 디버그 메시지 토글 함수
        function toggleDebugMessages(event) {
            const targetId = event.target.dataset.targetId;
            const botMessage = event.target.closest('.bot-message');
            if (!botMessage) return;

            const debugMessages = botMessage.querySelector('.debug-messages');
            const toggleButton = botMessage.querySelector('.message-toggle');

            // 상태 변경 및 저장
            const isHidden = debugMessages.classList.contains('debug-hidden');
            debugStates[targetId] = !isHidden; // true면 표시 중, false면 숨김 중

            if (isHidden) {
                // 디버그 메시지 표시
                debugMessages.classList.remove('debug-hidden');
                toggleButton.textContent = '디버그 메시지 숨기기';
            } else {
                // 디버그 메시지 숨기기
                debugMessages.classList.add('debug-hidden');
                const time = targetId ? processingTimes[targetId] : null;
                updateToggleButtonText(toggleButton, time);
            }

            saveChatHistory(); // 상태 변경 시 저장
            // scrollChatWindow();
        }

        // Waiting message functions
        function showWaitingMessage() {
            waitingMessageElement = document.createElement('div');
            waitingMessageElement.classList.add('chat-message', 'system-message');
            waitingMessageElement.style.backgroundColor = '#e0e0e0';
            waitingMessageElement.style.color = '#555555';
            waitingMessageElement.innerText = '응답 대기 중...';
            chatWindow.appendChild(waitingMessageElement);
            scrollChatWindow();
        }

        function removeWaitingMessage() {
            if (waitingMessageElement) {
                chatWindow.removeChild(waitingMessageElement);
                waitingMessageElement = null;
            }
        }

        // Chat utilities
        function scrollChatWindow() {
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }

        function saveChatHistory() {
            localStorage.setItem('chatHistory', chatWindow.innerHTML);
            localStorage.setItem('processingTimes', JSON.stringify(processingTimes));
            localStorage.setItem('debugStates', JSON.stringify(debugStates)); // 디버그 상태 저장
        }

        function appendMessage(type, text) {
            const message = document.createElement('div');
            message.classList.add('chat-message', `${type}-message`);
            message.innerHTML = formatText(text);
            chatWindow.appendChild(message);
            scrollChatWindow();
            return message;
        }

        // Start a new session
        function newSession() {
            if (!confirm("새 세션을 시작하시겠습니까? 채팅 기록이 삭제됩니다.")) return;
            [sendButton, newSessionButton, sentenceInput, metadataSelect].forEach(el => el.disabled = true);
            localStorage.removeItem('chatHistory');
            localStorage.removeItem('processingTimes');
            localStorage.removeItem('debugStates'); // 디버그 상태도 제거
            chatWindow.innerHTML = '';
            // 변수 재설정
            Object.keys(processingTimes).forEach(key => delete processingTimes[key]);
            Object.keys(debugStates).forEach(key => delete debugStates[key]);
            saveChatHistory();
            scrollChatWindow();
            [sendButton, newSessionButton, sentenceInput, metadataSelect].forEach(el => el.disabled = false);
        }

        function updateSuggestedButtons(suggestedInputs) {
            const suggestionContainer = document.querySelector('.suggestion-container');

            // Remove existing buttons
            suggestionContainer.innerHTML = '';

            suggestedInputs.forEach(input => {
                const button = document.createElement('button');
                button.classList.add('suggestion-button');
                button.innerText = input;
                button.addEventListener('click', () => {
                    sentenceInput.value = input;
                    sendRequest();
                });
                suggestionContainer.appendChild(button);
            });
        }

        function updateStatusDisplay(statusData) {
            // Update model status indicators
            const inputStatus = document.getElementById('inputStatus');
            const responseStatus = document.getElementById('responseStatus');

            if (statusData.model_status.input_to_instruction) {
                inputStatus.textContent = '정상';
                inputStatus.className = 'status-badge status-online';
            } else {
                inputStatus.textContent = '오프라인';
                inputStatus.className = 'status-badge status-offline';
            }

            if (statusData.model_status.response_generation) {
                responseStatus.textContent = '정상';
                responseStatus.className = 'status-badge status-online';
            } else {
                responseStatus.textContent = '오프라인';
                responseStatus.className = 'status-badge status-offline';
            }

            // Update GPU status
            const gpuStatusContainer = document.getElementById('gpuStatusContainer');
            gpuStatusContainer.innerHTML = ''; // Clear existing content

            // Create GPU status elements
            Object.keys(statusData.vram_status).forEach(gpuId => {
                const gpuData = statusData.vram_status[gpuId];
                const gpuStatusItem = document.createElement('div');
                gpuStatusItem.className = 'gpu-status-item';

                // Calculate usage percentage (assuming 24GB VRAM for RTX 3090)
                const maxVRAM = 24; // GB
                const usagePercent = (gpuData.used / maxVRAM) * 100;
                // Determine color class based on usage
                let colorClass = '';
                if (usagePercent > 90) {
                    colorClass = 'very-high-usage';
                } else if (usagePercent > 70) {
                    colorClass = 'high-usage';
                }

                gpuStatusItem.innerHTML = `
    <div class="gpu-name">${gpuData.name}</div>
    <div class="gpu-bar-container">
        <div class="gpu-bar ${colorClass}" style="width: ${usagePercent}%"></div>
    </div>
    <div class="gpu-usage">${gpuData.used.toFixed(1)} ${gpuData.unit}</div>
`;

                gpuStatusContainer.appendChild(gpuStatusItem);
            });

            // 마지막 업데이트 시간 표시
            lastStatusUpdate = new Date();
            statusLastUpdated.textContent = `마지막 업데이트: ${lastStatusUpdate.toLocaleTimeString()}`;
        }

        // Update the checkStatus function
        function checkStatus() {
            fetch(`http://1.233.219.93:{{ port_number }}/status`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Status 확인 중 오류 발생');
                    }
                    return response.json();
                })
                .then(data => {
                    // console.log('서버 상태:', data);
                    updateStatusDisplay(data);
                })
                .catch(error => {
                    console.error('Status 확인 실패:', error);

                    // Show error state in UI
                    const inputStatus = document.getElementById('inputStatus');
                    const responseStatus = document.getElementById('responseStatus');

                    if (inputStatus) inputStatus.textContent = '연결 오류';
                    if (responseStatus) responseStatus.textContent = '연결 오류';

                    const gpuStatusContainer = document.getElementById('gpuStatusContainer');
                    if (gpuStatusContainer) {
                        gpuStatusContainer.innerHTML = '<div class="gpu-status-loading">연결 오류</div>';
                    }

                    // 마지막 오류 시간 표시
                    if (statusLastUpdated) {
                        statusLastUpdated.textContent = `마지막 오류: ${new Date().toLocaleTimeString()}`;
                    }
                });
        }

        // 페이지 언로드 시 인터벌 정리 (메모리 누수 방지)
        window.addEventListener('beforeunload', () => {
            if (statusInterval) {
                clearInterval(statusInterval);
            }
        });
    </script>
</body>

</html>