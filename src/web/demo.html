<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LG전자-연세대 HVAC LLM 1차년도 데모</title>
    <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/variable/pretendardvariable.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>

<body>

    <div class="chat-container">
        <!-- Header section -->
        <div class="header-container">
            LG전자-연세대 HVAC LLM 1차년도 데모
            <div style="margin-left: auto; display: flex; align-items: center;">
                <img src="{{ url_for('static', filename='lg_logo.png') }}" alt="LG Logo">
                <img src="{{ url_for('static', filename='yonsei_logo.png') }}" alt="Yonsei Logo">
            </div>
        </div>

        <!-- Main content - Three column layout -->
        <div class="main-content">
            <div class="left-column">
                <!-- Metadata section -->
                <div class="metadata-column">
                    <div class="metadata-container">
                        <label for="metadataSelect">메타데이터 선택:</label>
                        <select id="metadataSelect">
                            <option value="">로딩 중...</option>
                        </select>
                    </div>
                    <div class="description-box" id="metadataDescription">
                        <!-- Add title-body vertical boxes -->
                        <div class="metadata-item">
                            <!-- <div class="metadata-title">제목</div>
                            <div class="metadata-content">
                                정보
                            </div> -->
                        </div>
                    </div>
                </div>

                <!-- Status section (vertically below metadata) -->
                <div class="status-section">
                    <div class="status-content" id="statusContent">
                        <div class="status-item">
                            <span class="status-label">모델 상태:</span>
                            <div class="status-indicators">
                                <div class="status-indicator">
                                    <span>입력처리:</span>
                                    <span id="inputStatus" class="status-badge">확인 중...</span>
                                </div>
                                <div class="status-indicator">
                                    <span>응답생성:</span>
                                    <span id="responseStatus" class="status-badge">확인 중...</span>
                                </div>
                            </div>
                        </div>
                        <div class="status-item">
                            <span class="status-label">GPU 상태:</span>
                            <div id="gpuStatusContainer" class="gpu-status-container">
                                <div class="gpu-status-loading">로딩 중...</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>


            <!-- Middle column - Chat -->
            <div class="chat-column">
                <div class="chat-window" id="chatWindow">
                    <!-- Chat messages will appear here -->
                </div>

                <div class="suggestion-container">
                    <!-- Suggested input buttons will be added here -->
                </div>

                <div class="input-container">
                    <input type="text" id="sentenceInput" placeholder="Enter a message...">
                    <button id="sendButton" onclick="sendRequest()">Send</button>
                    <button class="new-session-button" id="newSessionButton" onclick="newSession()">New Session</button>
                </div>
            </div>

            <!-- Right column - Debug -->
            <!-- <div class="debug-column">
                <div class="debug-title">디버그 메시지</div>
                <div class="debug-content" id="debugContent">
                    Debug messages will appear here 
                    시스템 디버그 메시지가 이곳에 표시됩니다.
                </div>
            </div> -->
        </div>
    </div>

    <script>
        // DOM Elements
        const sendButton = document.getElementById('sendButton');
        const newSessionButton = document.getElementById('newSessionButton');
        const sentenceInput = document.getElementById('sentenceInput');
        const chatWindow = document.getElementById('chatWindow');
        const metadataSelect = document.getElementById('metadataSelect');
        const metadataDescription = document.getElementById('metadataDescription');
        let waitingMessageElement = null;
        let availableMetadatas = {};
        let botResponseBuffer = '';

        // Event Listeners
        sentenceInput.addEventListener('keyup', e => e.key === 'Enter' && sendRequest());
        sendButton.addEventListener('click', sendRequest);
        newSessionButton.addEventListener('click', newSession);
        metadataSelect.addEventListener('change', () => updateMetadataDescription(metadataSelect.value));

        // Initialize
        window.onload = () => {
            const chatHistory = localStorage.getItem('chatHistory');
            if (chatHistory) {
                chatWindow.innerHTML = chatHistory;
                scrollChatWindow();
            }
            loadMetadatas();
            createSuggestedButtons();
            checkStatus();
        };

        // Load metadata from server
        function loadMetadatas() {
            fetch(`http://1.233.219.93:{{ port_number }}/available_metadatas`)
                .then(response => response.json())
                .then(data => {
                    availableMetadatas = data;
                    metadataSelect.innerHTML = '';

                    const metadataNames = Object.keys(availableMetadatas);
                    metadataNames.forEach(name => {
                        const option = document.createElement('option');
                        option.value = name;
                        option.textContent = name;
                        metadataSelect.appendChild(option);
                    });

                    if (metadataNames.length > 0) {
                        metadataSelect.value = metadataNames[0];
                        updateMetadataDescription(metadataNames[0]);
                    }
                })
                .catch(error => {
                    console.error('메타데이터 로드 오류:', error);
                    metadataSelect.innerHTML = '<option value="">메타데이터 로드 실패</option>';
                });
        }

        // Create metadata description recursively
        function createMetadataDescriptionFromList(data, depth = 0) {
            if (depth === 0) metadataDescription.innerHTML = '';

            for (const item of data) {
                if (Array.isArray(item) && item.length === 2) {
                    const [title, content] = item;

                    if (Array.isArray(content)) {
                        // Section header
                        const sectionEl = document.createElement('div');
                        sectionEl.className = 'metadata-section';
                        sectionEl.style.paddingLeft = `${depth * 16}px`;
                        sectionEl.style.marginBottom = '5px';
                        sectionEl.style.fontWeight = 'bold';
                        sectionEl.textContent = title;
                        metadataDescription.appendChild(sectionEl);

                        if (content.every(subItem => Array.isArray(subItem))) {
                            // Process nested arrays
                            createMetadataDescriptionFromList(content, depth + 1);
                        } else {
                            // Simple list items
                            for (const subItem of content) {
                                const itemEl = document.createElement('div');
                                itemEl.className = 'metadata-item';
                                itemEl.style.paddingLeft = `${(depth + 1) * 16}px`;
                                itemEl.style.marginBottom = '4px';
                                itemEl.textContent = `| ${subItem}`;
                                metadataDescription.appendChild(itemEl);
                            }
                        }
                    } else {
                        // Key-value pair
                        const itemEl = document.createElement('div');
                        itemEl.className = 'metadata-item';
                        itemEl.style.paddingLeft = `${depth * 16}px`;
                        itemEl.style.marginBottom = '4px';
                        itemEl.innerHTML = `<span style="font-weight: bold;">${title}:</span> ${content}`;
                        metadataDescription.appendChild(itemEl);
                    }
                } else if (Array.isArray(item) && item.length >= 2 && typeof item[0] === 'string') {
                    // Special case array items
                    const keyEl = document.createElement('div');
                    keyEl.className = 'metadata-item';
                    keyEl.style.paddingLeft = `${(depth + 1) * 16}px`;
                    keyEl.style.marginBottom = '4px';
                    keyEl.textContent = item.join(': ');
                    metadataDescription.appendChild(keyEl);
                } else {
                    // Simple string item
                    const itemEl = document.createElement('div');
                    itemEl.className = 'metadata-item';
                    itemEl.style.paddingLeft = `${(depth + 1) * 16}px`;
                    itemEl.style.marginBottom = '4px';
                    itemEl.textContent = item;
                    metadataDescription.appendChild(itemEl);
                }
            }
        }

        // Update metadata description
        function updateMetadataDescription(metadataName) {
            if (availableMetadatas[metadataName]) {
                createMetadataDescriptionFromList(availableMetadatas[metadataName]);
            } else {
                metadataDescription.innerHTML = '선택된 메타데이터에 대한 정보가 없습니다.';
            }
        }

        // Helper functions
        const escapeHTML = str => str.replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");

        const formatText = str => {
            const escapedStr = escapeHTML(str);
            return escapedStr
                .replace(/&lt;h1 (.*?)&gt;/g, '<div class="h1">$1</div>')
                .replace(/&lt;h2 (.*?)&gt;/g, '<div class="h2">$1</div>')
                .replace(/&lt;h3 (.*?)&gt;/g, '<div class="h3">$1</div>')
                .replace(/^((?!<div class="h[123]">).+)$/gm, '<div class="normal">$1</div>')
                .replace(/&lt;br&gt;/g, '\n');
        };

        // Send request to server
        function sendRequest() {
            const sentence = sentenceInput.value.trim();
            const selectedMetadata = metadataSelect.value;

            if (!sentence) return;
            if (!selectedMetadata) {
                alert('메타데이터를 선택해주세요.');
                return;
            }

            // Add user message to chat
            appendMessage('user', sentence);
            saveChatHistory();
            sentenceInput.value = '';
            scrollChatWindow();

            // Disable inputs during processing
            [sendButton, newSessionButton, sentenceInput, metadataSelect].forEach(el => el.disabled = true);
            // Also disable suggestion buttons
            document.querySelectorAll('.suggestion-button').forEach(button => button.disabled = true);
            showWaitingMessage();
            botResponseBuffer = '';

            // Create bot message element
            const botMessageElement = appendMessage('bot', '');
            botMessageElement.style.display = 'none';

            // Create EventSource for streaming response
            const eventSource = new EventSource(
                `http://1.233.219.93:{{ port_number }}/process?sentence=${encodeURIComponent(sentence)}&metadata_name=${encodeURIComponent(selectedMetadata)}`
            );

            eventSource.onmessage = function (event) {
                removeWaitingMessage();
                botMessageElement.style.display = 'block';

                if (event.data === "finish") {
                    eventSource.close();
                    [sendButton, newSessionButton, sentenceInput, metadataSelect].forEach(el => el.disabled = false);
                    document.querySelectorAll('.suggestion-button').forEach(button => button.disabled = false);
                    saveChatHistory();
                } else {
                    botResponseBuffer += event.data + '\n';
                    botMessageElement.innerHTML = formatText(botResponseBuffer);
                    scrollChatWindow();
                }
            };

            eventSource.onerror = function (error) {
                removeWaitingMessage();
                botMessageElement.style.display = 'block';
                botMessageElement.innerText = 'An error occurred while processing your request.';
                saveChatHistory();

                eventSource.close();
                [sendButton, newSessionButton, sentenceInput, metadataSelect].forEach(el => el.disabled = false);
                document.querySelectorAll('.suggestion-button').forEach(button => button.disabled = false);
            };
        }

        // Waiting message functions
        function showWaitingMessage() {
            waitingMessageElement = document.createElement('div');
            waitingMessageElement.classList.add('chat-message', 'system-message');
            waitingMessageElement.style.backgroundColor = '#e0e0e0';
            waitingMessageElement.style.color = '#555555';
            waitingMessageElement.innerText = '응답 대기 중...';
            chatWindow.appendChild(waitingMessageElement);
            scrollChatWindow();
        }

        function removeWaitingMessage() {
            if (waitingMessageElement) {
                chatWindow.removeChild(waitingMessageElement);
                waitingMessageElement = null;
            }
        }

        // Chat utilities
        function scrollChatWindow() {
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }

        function saveChatHistory() {
            localStorage.setItem('chatHistory', chatWindow.innerHTML);
        }

        function appendMessage(type, text) {
            const message = document.createElement('div');
            message.classList.add('chat-message', `${type}-message`);
            message.innerHTML = formatText(text);
            chatWindow.appendChild(message);
            scrollChatWindow();
            return message;
        }

        // Start a new session
        function newSession() {
            if (!confirm("새 세션을 시작하시겠습니까? 채팅 기록이 삭제됩니다.")) return;

            [sendButton, newSessionButton, sentenceInput, metadataSelect].forEach(el => el.disabled = true);
            localStorage.removeItem('chatHistory');
            chatWindow.innerHTML = '';
            saveChatHistory();
            scrollChatWindow();
            [sendButton, newSessionButton, sentenceInput, metadataSelect].forEach(el => el.disabled = false);
        }

        // Create suggestion buttons
        const suggestedInputs = [
            '현재 우리반 실내온도 알려줘.',
            '지금 우리반 에어컨 전원 꺼져있어?',
            '지금 가장 더운반 알려줘.',
            '우리반과 옆반의 현재 온도차이 알려줘.',
            '오늘 우리반 평균온도 알려줘',
            '이번달 우리반 가장 더웠던 날이 언제야?',
            '10년전 우리반 온도 알려줘',
            '요번달에 가장 더웠던 날 갈켜주소',
            '우리반과 옆반 중 오늘 하루 평균온도가 더 높은곳을 알려줘',
            '우리ㅣ 반 형ㄴ재온도 알려줘',
        ];

        function createSuggestedButtons() {
            const suggestionContainer = document.querySelector('.suggestion-container');
            suggestedInputs.forEach(input => {
                const button = document.createElement('button');
                button.classList.add('suggestion-button');
                button.innerText = input;
                button.addEventListener('click', () => {
                    sentenceInput.value = input;
                    sendRequest();
                });
                suggestionContainer.appendChild(button);
            });
        }
        function updateStatusDisplay(statusData) {
            // Update model status indicators
            const inputStatus = document.getElementById('inputStatus');
            const responseStatus = document.getElementById('responseStatus');

            if (statusData.model_status.input_to_instruction) {
                inputStatus.textContent = '정상';
                inputStatus.className = 'status-badge status-online';
            } else {
                inputStatus.textContent = '오프라인';
                inputStatus.className = 'status-badge status-offline';
            }

            if (statusData.model_status.response_generation) {
                responseStatus.textContent = '정상';
                responseStatus.className = 'status-badge status-online';
            } else {
                responseStatus.textContent = '오프라인';
                responseStatus.className = 'status-badge status-offline';
            }

            // Update GPU status
            const gpuStatusContainer = document.getElementById('gpuStatusContainer');
            gpuStatusContainer.innerHTML = ''; // Clear existing content

            // Create GPU status elements
            Object.keys(statusData.vram_status).forEach(gpuId => {
                const gpuData = statusData.vram_status[gpuId];
                const gpuStatusItem = document.createElement('div');
                gpuStatusItem.className = 'gpu-status-item';

                // Calculate usage percentage (assuming 24GB VRAM for RTX 3090)
                const maxVRAM = 24; // GB
                const usagePercent = (gpuData.used / maxVRAM) * 100;

                // Determine color class based on usage
                let colorClass = '';
                if (usagePercent > 90) {
                    colorClass = 'very-high-usage';
                } else if (usagePercent > 70) {
                    colorClass = 'high-usage';
                }

                gpuStatusItem.innerHTML = `
            <div class="gpu-name">${gpuData.name}</div>
            <div class="gpu-bar-container">
                <div class="gpu-bar ${colorClass}" style="width: ${usagePercent}%"></div>
            </div>
            <div class="gpu-usage">${gpuData.used.toFixed(1)} ${gpuData.unit}</div>
        `;

                gpuStatusContainer.appendChild(gpuStatusItem);
            });
        }

        // Update the checkStatus function
        function checkStatus() {
            fetch(`http://1.233.219.93:{{ port_number }}/status`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Status 확인 중 오류 발생');
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('서버 상태:', data);
                    updateStatusDisplay(data);
                })
                .catch(error => {
                    console.error('Status 확인 실패:', error);

                    // Show error state in UI
                    const inputStatus = document.getElementById('inputStatus');
                    const responseStatus = document.getElementById('responseStatus');

                    if (inputStatus) inputStatus.textContent = '연결 오류';
                    if (responseStatus) responseStatus.textContent = '연결 오류';

                    const gpuStatusContainer = document.getElementById('gpuStatusContainer');
                    if (gpuStatusContainer) {
                        gpuStatusContainer.innerHTML = '<div class="gpu-status-loading">연결 오류</div>';
                    }
                });
        }



        const statusInterval = setInterval(checkStatus, 1000);

        // 페이지 언로드 시 인터벌 정리 (메모리 누수 방지)
        window.addEventListener('beforeunload', () => {
            clearInterval(statusInterval);
        });

    </script>
</body>

</html>